
// Very simple test case.
(1 + 2 + 3);

// Let-expressions:
{ 
  let x = 1+0;
  let y = 2+0;
  x*y;
};

// If-expressions:
{ 
  let x = 1+0;
  let y = 2+0;
  if (1 == 2) then x*x else y*y;
};

// Check for correct continuation of nested if.
{ 
  let a = 1+0;
  let b = a + (1 + (if (a==2) then 3 else 4));
  if (b == a) then a+5 else b+5;
};

// Ensure that the Lets don't introduce empty blocks.
{ 
  let x = 1+0;
  let y = {
    let z = {
      let a = x; 
      a+a;
    };
    z*z;
  };
  y/y;
};

// Continuation passing between if and let
// Make the z branches continue directly to x/x, without empty blocks.
{ 
  let a = 1+0;
  let b = 2+0;
  if (a == b) then {
    let y = a+3; 
    y*y;
  }
  else {
    let z = b+3;
    if (z < 4) then z+z else z*z;
  };
};

// First version of locally defined functions.
{ 
  let a = 1+0;
  let b = 2+0;
  let f(y: Int): Int -> y+1;
  let g(z: Int): Int -> f(z*2);
  g(a*b);
};

// Locally defined functions with multiple arguments.
{
  let a = 1+0;
  let b = 2+0;
  let f(y: Int, z: Int): Int -> y*z+1;
  let g(c: Int, d: Int): Int -> f(c*2, d*2);
  g(a,b);
};

// The first real code, with a loop!.
{
  let n = 100 + 0;
  letrec loop(i: Int, total: Int): Int -> {
    if (i < n) then loop(i+1, total+i) else total;
  };
  loop(0,0);
};

// Handling of nested function calls.
{
  let n = 100 + 0;
  let foo(z: Int): Int -> z*z;
  let bar(w: Int): Int -> w+0;
  letrec loop(i: Int, total: Int): Int -> {
    if (i < n) then loop(i+1, total+i) else total;
  };
  loop(foo(0), bar(0));
};

// More handling of nested functions.
{ 
  let n = 100 + 0;
  let foo(z: Int): Int -> z*z;
  letrec loop(i: Int, total: Int): Int -> {
    if (i < n) then loop(i+1, total+i) else total;
  };
  let w = foo(loop(0,0) + 3);
  w*n;
};


// Handle multiple function calls
// Notice that the function calls don't have to be in tail positions,
// so long as the CPS transform can convert them to tail calls.
// It can convert them so long as all calls to the function return to the 
// same point in the code.
{ 
  let n = 100 + 0;
  letrec loop(i: Int, total: Int): Int -> {
    if (i < n) then loop(i+1, total+i) else total;
  };
  let m = if (n < 50) then loop(0, 0) else loop(0, n+1);
  m+1;
};


// Nested loops.
{
  let n = 100 + 0;
  let m = 100 + 0;
  letrec loop_m(j: Int, total_m: Int): Int -> {
    letrec loop_n(i: Int, total_n: Int): Int -> {
      if (i < n) then {
        let tn = total_n + i + j;
        loop_n(i+1, tn);
      }
      else total_n;
    };
    if (j < m) then {
      let tm = loop_n(0, total_m);
      loop_m(j+1, tm);
    }
    else total_m;
  };
  loop_m(0, 0);
};


// Test handling of SSA in a DAG.
{
  let a = 1+0;
  let b = 2+0;
  var c = 0;
  var d = 0;
  var e = 0;
  let z = if (a == b) then {
    d := 1;
    if (a < 10) then {
      c := 1;
      a*a;
    }
    else {
      c := 2;
      e := 2;
      a;
    };
  } else {
    c := 3;
    d := 3;
    b*b;
  };
  z + c^ + d^ + e^;
};


// SSA pass for loops.
{
  let n = 100+0;
  var total = 0;
  var unchanged = 0;
  letrec loop(i: Int): Int -> {
    if (i < n) then {
      total := total + 1;
      loop(i+1);
    }
    else 0;
  };
  loop(0);
  unchanged^;
};





